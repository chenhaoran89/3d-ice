/******************************************************************************
 *                                                                            *
 * Source file "Flex/stack_description_scanner.l"                             *
 *                                                                            *
 * Flex source file to process with Flex >= 2.5.35 to generate a scanner.     *
 *                                                                            *
 * Compile with "flex stack_scanner.l" to obtain the files "stack_scanner.h"  *
 * and "stack_scanner.c". This action must be done after bison because it     *
 * depends on the header file so generated.                                   *
 *                                                                            *
 * EPFL-STI-IEL-ESL                                                           *
 * BÃ¢timent ELG, ELG 130                                                      *
 * Station 11                                                                 *
 * 1015 Lausanne, Switzerland                    alessandro.vincenzi@epfl.ch  *
 ******************************************************************************/

%{
#include <string.h>
#include <stdlib.h>

/* Header file generated by bison containing the tokens integer values and */
/* the variable "yystype yylval".                                          */
#include "stack_description_parser.h"
%}

/* Instructs flex to write a C header-file. This file contains function     */
/* prototypes, external variables, and types used by the scanner. Only the  */
/* external API is exported by the header file. Many macros that are usable */
/* from within scanner actions are not exported to the header file.         */

%option header-file="Include/stack_description_scanner.h"

/* Directs flex to write the scanner to outfile instead of lex.yy.c. */

%option outfile="Sources/stack_description_scanner.c"

/* Changes the default `yy' prefix used by flex for all globally-visible */
/* variable and function names to instead be `PREFIX'.                   */

%option prefix="stack_description_"

/* Directs flex to generate a scanner that maintains the number of the */
/* current line read from its input in the global variable yylineno.   */

%option yylineno

/* Makes the scanner not call yywrap() upon an end-of-file, but simply */
/* assume that there are no more files to scan.                        */

%option noyywrap

/* Warn about certain things. In particular, if the default rule can be */
/* matched but no default rule has been given, the flex will warn you.  */

%option warn

/* Do not generate the unput() function */

%option nounput

/* Generate the default rule */

%option default

/* Instructs flex to generate a reentrant C scanner. The generated scanner */
/* may safely be used in a multi-threaded environment.                     */

%option reentrant

/* Instructs flex to generate a C scanner that is meant to be called by a GNU */
/* bison parser. The scanner has minor API changes for bison compatibility.   */
/* In particular, the declaration of yylex is modified to take an additional  */
/* parameter, yylval.                                                         */

%option bison-bridge

/* Definitions used to simplify the scanner specification */

unsigned_integer        [[:digit:]]+
signed_integer          [+-]?[[:digit:]]+
exponent                [eE]{signed_integer}
double                  {signed_integer}\.{unsigned_integer}{exponent}?
identifier              [[:alpha:]](\_|[[:alnum:]])*
path_begin              (\.{1,2}\/|\/)?
path                    \"{path_begin}{identifier}(\/|\.{1,2}|{identifier})*\"

/* exclusive start conditions to exclude C/C++ like comments in */
/* the scanned file.                                            */

%x ONE_LINE_COMMENT
%x MULTIPLE_LINE_COMMENT

/* Begin of "rules" section of the flex file. For every token read from the */
/* input file that match one of the rule in the left column the scanner     */
/* executes the action in the right column. If a value which is not the id  */
/* of the token must be passed to the parser, it is given to the shared     */
/* variable yylval. Comments are discarded.                                 */

%%

[[:space:]]*                 ;

"//"                         BEGIN(ONE_LINE_COMMENT) ;
"/*"                         BEGIN(MULTIPLE_LINE_COMMENT) ;

":"                          return yytext[0] ;
";"                          return yytext[0] ;

"capacity"                   return CAPACITY ;
"cell"                       return CELL ;
"channel"                    return CHANNEL ;
"chip"                       return CHIP ;
"coefficient"                return COEFFICIENT ;
"coolant"                    return COOLANT ;
"conductivity"               return CONDUCTIVITY ;
"die"                        return DIE ;
"dimensions"                 return DIMENSIONS ;
"first"                      return FIRST ;
"floorplan"                  return FLOORPLAN ;
"flow"                       return FLOW ;
"heat"                       return HEAT ;
"height"                     return HEIGHT ;
"incoming"                   return INCOMING ;
"layer"                      return LAYER ;
"last"                       return LAST ;
"length"                     return LENGTH ;
"material"                   return MATERIAL ;
"mm"                         return MM ;
"on"                         return ON ;
"rate"                       return RATE ;
"source"                     return SOURCE ;
"specific"                   return SPECIFIC ;
"stack"                      return STACK ;
"temperature"                return TEMPERATURE ;
"thermal"                    return THERMAL ;
"transfer"                   return TRANSFER ;
"um"                         return UM ;
"volumetric"                 return VOLUMETRIC ;
"wall"                       return WALL ;
"width"                      return WIDTH ;

{double}                     {
                               yylval->double_v = atof(yytext) ;
                               return DVALUE ;
                             }

{signed_integer}             {
                               yylval->int_v = atoi(yytext) ;
                               return IVALUE ;
                             }

{identifier}                 {
                               yylval->string = strdup(yytext) ;
                               return IDENTIFIER ;
                             }

{path}                       {
                               yylval->string
                                 = malloc (sizeof(char) * (strlen(yytext)-2)) ;
                               strncpy
                               (
                                 yylval->string,
                                 yytext+1,
                                 strlen(yytext)-2
                               );
                               return PATH;
                             }

<ONE_LINE_COMMENT>\n              BEGIN(INITIAL);
<ONE_LINE_COMMENT>.               ;
<MULTIPLE_LINE_COMMENT>"*/"       BEGIN(INITIAL);
<MULTIPLE_LINE_COMMENT>[^*\n]+    ;
<MULTIPLE_LINE_COMMENT>"*"[^/]    ;
<MULTIPLE_LINE_COMMENT>\n         ;
