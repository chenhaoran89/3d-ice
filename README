 ##############################################################################
 # README fuile "3D-ICE/README"                                               #
 #                                                                            #
 # This file is part of 3D-ICE 1.0 (beta).                                    #
 #                                                                            #
 # 3D-ICE is free software: you can  redistribute it and/or  modify it  under #
 # the terms of the  GNU General  Public  License as  published by  the  Free #
 # Software  Foundation, either  version  3  of  the License,  or  any  later #
 # version.                                                                   #
 #                                                                            #
 # 3D-ICE is  distributed  in the hope  that it will  be useful, but  WITHOUT #
 # ANY  WARRANTY; without  even the  implied warranty  of MERCHANTABILITY  or #
 # FITNESS  FOR A PARTICULAR  PURPOSE. See the GNU General Public License for #
 # more details.                                                              #
 #                                                                            #
 # You should have  received a copy of  the GNU General  Public License along #
 # with 3D-ICe. If not, see <http://www.gnu.org/licenses/>.                   #
 #                                                                            #
 #                             Copyright (C) 2010                             #
 #   Embedded Systems Laboratory - Ecole Polytechnique Federale de Lausanne   #
 #                            All Rights Reserved.                            #
 #                                                                            #
 # Authors: Arvind Sridhar                                                    #
 #          Alessandro Vincenzi                                               #
 #          Martino Ruggiero                                                  #
 #          Thomas Brunschwiler                                               #
 #          David Atienza                                                     #
 #                                                                            #
 # EPFL-STI-IEL-ESL                                                           #
 # Bstiment ELG, ELG 130                                                      #
 # Station 11                                           3d-ice@listes.epfl.ch #
 # 1015 Lausanne, Switzerland                  http://esl.epfl.ch/3d-ice.html #
 ##############################################################################

3D-ICE stands for "3D Interlayer Cooling Emulator". It is a Linux  based Thermal
Emulator Library  written in C, which can perform  transient thermal analyses of
vertically  stacked 3D integrated  circuits with  inter-tier Microchannel Liquid
Cooling. It is based on Compact Transient Thermal Modeling (CTTM) of solids and
liquids.

# 1 - Dependencies
################################################################################

The 3D-ICE library has been written and developed using:

- bison 2.4.1
- flex 2.5.35
- gcc 4.1.2

Please make sure that  these tools are installed on your system before compiling
and  that the  corresponding  variables in makefile.def point to the  respective
binary  files. To  use 3D-ICE, you  must also  downlad and  compile the  SuperLU
library, available at "http://crd.lbl.gov/~xiaoye/SuperLU/".

# 2 - Compile SuperLU
################################################################################

Before compiling 3D-ICE, you  must compile the  SuperLU library executing  these
commands (if you are on a general  Linux platform, otherwise choose the make.inc
file that corresponds to your architecture):

  $ wget http://crd.lbl.gov/~xiaoye/SuperLU/superlu_4.0.tar.gz
  $ tar xvfz superlu_4.0.tar.gz
  $ cd SuperLU_4.0/
  $ cp MAKE_INC/make.linux make.inc

Then check and edit the  SuperLUroot variable in ./make.inc and  select the blas
library  before compiling. You  can either  use a blas library  installed on you
system  or the blas library  supplied by the authors  of SuperLU (see the README
file).

If  you  decide to  use the former  then  the variable  BLASDEF must  be set and
BLASLIB must point to your blas library. Then compile SuperLU with

  $ make

In  the latter  case, BLASDEF  must  be  unset and  BLASLIB must  points to  the
./libblas.a archive. Then compile SuperLU with

  $ make blaslib
  $ make

# 3 - Compile 3D-ICE
################################################################################

Check and edit the "SLU_MAIN"  variable in ./makefile.def  to make it points  to
the  main folder of SuperLU  and then  select the value of SLU_LIBS according to
the choice done above when compiling SuperLU. You can then compile 3D-ICE with:

  $ tar xvfz 3D-ICE-1.0-beta.tar.gz
  $ cd 3D-ICE
  $ make



# 4 - Using the library.
################################################################################

3D-ICE  accepts  the  physical description  of the 3D-IC stack  in the form of a
simple  and  easy-to-understand  text  file called  the  "Stack Descriptor". The
thermal  power  distribution of the individual dies can be given to 3D-ICE using
"Floorplan" text file. There are  a  multitude of functions that enable the user
to print  thermal maps  of  individual dies, temperature  evolution  at a single
floorplan element against time etc.

Together with the library sources you will also have an example that show how to
use 3D-ICE to emulate a 3D chip. See files in the ./examples folder.

Include stack_description.h and thermal_data.h ....


# 5 - Stack Description File.
################################################################################

The "Stack Descriptor" file (*.stk)  specifics all the physical and  geometrical
characteristics  of  the 3D-IC  to simulate. The  extension  of the  file is not
relevant, meaning  that  it will  be parsed  independently from  its presence or
content.

Within the file, keywords  must be written in low case  and all the white spaces
belonging to

      [:space:]

are  skipped  (see POSIX  character classes).  Identifiers (here reported as ID)
must match the following regular expression:

      [a-zA-Z] ( _ | [a-zA-Z0-9] )*

Floating points values, reported as DVALUE, must belong to

      [+-]? [0-9]+ ( \. [0-9]+ ( [eE] [+-]? [0-9]+ )? )?

For more details please refers to the flex sources in 3D-ICE/flex.

It is also  possible, as in C or Java, to  comment all  the remaining characters
until the end of the line ( // ) or to suppress an entire block ( /* ... */ ).

The stack  description file contains six main sections and they must be declared
following this order:

      materials
      environment heat sink
      channel
      dies
      stack
      dimensions

# 5.1 - Materials
################################################################################

The first section of the file contains a list of at least one material. A single
material is declared with this syntax:

     material MATERIAL_ID :
         thermal conductivity     DVALUE ;
         volumetric heat capacity DVALUE ;

where:

- M_ID is a unique identifier to refer to this material;
- Thermal conductivity is expressed as [ W / ( um  * K ) ];
- Volumetric heat capacity is expressed as [ J / ( um3 * K ) ].

Materials declared here but not used in the following sections (channel, dies or
stack) will be reported with a warning messages (stderr).


# 5.2 - Environment heat sink
################################################################################

This section  specifies the parameters  regarding the heat exchange  through the
top-most surface of the 3D-IC stack. All the sides of  the chip, except  the top
surface, are  modeled  as  adiabatic  (no  heat  exchange). This  section can be
omitted.

      environment heat sink :
         heat transfer coefficient DVALUE ;
         environment temperature DVALUE ;

where:

- Heat transfer coefficient is expressed as [ W / ( um2 * K ) ];
- Environment temperature is expressed as [ K ].

# 5.3 - Channel
################################################################################

The  channel section  collects information  about the liquid cooling parameters.
There is only one channel section since all the channel layers interlayed in the
3D stack will share the  same structure. This section can  be omitted to support
the emulation of 3D-IC without a liquid cooling system (solid only).

      channel :
         height DVALUE ;
         channel length DVALUE ;
         wall    length DVALUE ;
         ( first wall length DVALUE ; )?
         ( last  wall length DVALUE ; )?
         wall material MATERIAL_ID  ;
         coolant flow rate DVALUE ;
         coolant heat transfer coefficient [ DVALUE | SIDE DVALUE ,
                                                      TOP  DVALUE ,
                                                      BOTTOM DVALUE ] ;
         coolant volumetric heat capacity DVALUE ;
         coolant incoming temperature DVALUE ;

where:

- Height, in [ um ], corresponds to the height of the channel layer;
- Channel  and wall  length  are the  lengths, in [ um ], of  the  corresponding
  columns in which the layer is  divided. Walls and channels are alternated  but
  their  quantity (the sum) must  be odd since  the channel layer must begin and
  end with walls.
- First and last wall length, in [ um ], are optional properties that represents
  the length of  the west-most (the first) and  east-most (the last)  walls. The
  brackets ( ) and ? are not part of  the syntax but  they are used to  indicate
  that  it is  an optional  declaration.  If one  of the  two  (or both) is  not
  declared, the corresponding dimension will be set using the length of the wall.
- MATERIAL_ID is the identifier of the material composing the walls (the id must
  be previously declared in the materials section).
- The coolant flow rate is expressed in [ ml / min ] and it refers to the volume
  of coolant per channel layer that crosses the chip;
- The coolant heat transfer coefficient(s) is expressed in [ (W / ( um2 * K ) ];
  For this value  it is possible  to specify a  unique  one or distinguish three
  different  values: "side" for the liquid - wall material, top for the liquid -
  top  layer material and bottom for liquid - bottom layer material. The symbols
  [, | and ] are not part of the syntax but they indicate that there must be one
  of the two alternatives.
- The coolant volumetric heat capacity is expressed as [ J / ( um3 * K ) ];
- The temperature of the coolant entering the channels is expressed as [ K ].

If both the  ambient heat sink and  the channel sections are not declared in the
.stk file then the parsing will end with a warning message.

# 5.4 - Dies
################################################################################

A die  is a group of  layers stacked  together to form a single component to use
as unity when  declaring the sequence of  stack element in the  stack section of
the file. The dies  section must  contain at least one  die element. A  die must
contain one source (active) layer and zero or more normal layers (inactive). The
source layer can be placed at the bottom, in the middle or at the top.

      die DIE_ID :
         ( layer  DVALUE MATERIAL_ID ; )*
           source DVALUE MATERIAL_ID ;
         ( layer  DVALUE MATERIAL_ID ; )*

where:

- DIE_ID is the unique identifier used to refer to the declared die;
- DVALUE is the height of the layer, in [ um ];
- MATERIAL_ID is the previously  declared identifier  of the material  composing
  the layer.

In this context, the symbols ( ) * refer to  zero or  more instances of a layer.
The order of the  layers within the die reflects the vertical disposition in the
emulated chip: the first layer declared is the top  most layer in the die  while
the last one is the one at the bottom (closer to the mainboard).

# 5.5 - Stack
################################################################################

This section declare the vertical structure of the stack. The elements available
to compose the 3D chip can be: dies (previously declared), layers and channels.
These three elements can be declared as:

  stack :
      ( layer   LL_ID  DVALUE MATERIAL_ID ; )*
      ( channel CC_ID ; )*
      ( die     DD_ID  DIE_ID floorplan "PATH" ; )*

where:
- LL_ID, CC_ID, DD_ID are  identifiers used  to name the stack elements and they
  can be  used in the C code to refer to the corresponding element. They must be
  unique;
- MATERIAL_ID is the identifier of the material composing the declared layer and
  DVALUE is its height in [ um ];
- DIE_ID is the  identifier of a  die (previously declared) and PATH is the path
  to the floorplan file. This floorplan will be placed  on the layer  inside the
  die  declared  with  the  source  keyword. The  floorplan  files  declare  the
  structure of  the  floorplan  (as set of  floorplan  elements) and their power
  values. If two  dies in the stack  have the  same  floorplan  but  during  the
  simulation they have a different  behavior (different power values), then they
  (the 2 dies) must be declared in the stack with two different floorplan files.

The symbols (, ) and * indicate that there must be zero or more instances of the
same line. For the sake of simplicity, the above grammar describing the stack
section but the final sequence must satisfy the following constrains:

- there must be at least one die
- it cannot begin or finish with a channel
- there cannot be two consecutive channels
- channels can be used only if previously declared
- channels can be omitted only if not declared
- layers are optional

Declaring a layer  is not  mandatory but we left this option  to support  stacks
with  irregular patterns of dies and channels or to build layers before or after
a  channel since  the height of  the channel  corresponds to  the height of  its
layer.

The final sequence of stack elements  reflects their  vertical location, as  for
layers  in the die. The first line corresponds to the top-most element while the
last declare the element closer to the board (bottom-most).

# 5.5 - Dimensions
################################################################################

The last section  of the stk file declares the dimensions  in [ um ] of the chip
and of the thermal cells as reported:

      dimensions :
         chip   length DVALUE , width DVALUE ;
         cell   length DVALUE , width DVALUE ;

... See arvind's file

# 5 - The Floorplan File
################################################################################

Every die in the stack must be related to a "Floorplan File" (*.flp), which
contains the list of the functional blocks (cores, caches, memories, etc) that
belongs to the simulated IC. Every functional block, here called Floorplan
Element, is described as a rectangle with a name, a position and a dimension
and a list of power values seen as source of heat. These component are considered
to be placed on the layer of the related die declared as "source" layer (see ???).

Every floorplan element in the floorplan file can be declared with the following
syntax:

  IDENTIFIER :
      position  UIVALUE , UIVALUE ;
      dimension UIVALUE , UIVALUE ;
      power values DVALUE ( , DVALUE )* ;

where

- IDENTIFIER is the unique identifier used to name the floorplan element. This
  string must be unique within the floorplan file it belongs to but it can be
  used on a different file.
- position, expressed in [ um ] is the (x,y) coordinate of the south-west corner
  of the floorplan element
- dimension indicates the size of the element as the (length, width) dimensions
  of the rectangle used to model it
- DVALUE is the power consumption, expressed in [ W ]. Power values are declared
  as a comma-separated list with at least one element.

During the parsing of the Floorplan File, the values describing the elements are
checked to verify that all the elements are inside the chip and that they do
not overlap. Then, they will be placed on the grid of cells as (where the cell
center is).

The number of power values inserted for each floorplan element, instead, must be
constant. The C function fill_stack_description parses the stack description
first and then parses all the Floorplan Files starting from the bottom most
die in the stack. Therefore, the number of power values declared in the first
floorplan element in that die will be used as a reference to check all the others
elements. Power values in excess will be discarded and reported with a warning
message while the lack of them will be considered as an error. This is done to
guarantee that all the floorplan elements in all the floorplan files can inject
heat in the 3D-chip for at least the same amount of time.
